# shellcheck shell=bash

REQUIRED_DIRENV_VERSION="2.21.3"

_NIX_DIRENV_LOG_PREFIX="nix-direnv: "

_nix_direnv_info() {
  log_status "${_NIX_DIRENV_LOG_PREFIX}$*"
}

_nix_direnv_warning() {
  if [[ -n $DIRENV_LOG_FORMAT ]]; then
    local msg=$* color_normal='' color_warning=''
    if [[ -t 2 ]]; then
      color_normal="\e[m"
      color_warning="\e[33m"
    fi
    # shellcheck disable=SC2059
    printf "${color_warning}${DIRENV_LOG_FORMAT}${color_normal}\n" \
      "${_NIX_DIRENV_LOG_PREFIX}${msg}" >&2
  fi
}

_nix_direnv_fatal() {
  log_error "${_NIX_DIRENV_LOG_PREFIX}$*"
  # exit 1 rather than return 1 because we may not be running in strict mode
  exit 1
}

_nix() {
  nix --extra-experimental-features "nix-command flakes" "$@"
}

_nix_direnv_preflight () {
  if [[ -z "$direnv" ]]; then
    _nix_direnv_fatal "\$direnv environment variable was not defined. Was this script run inside direnv?"
  fi

  if ! has direnv_version || ! direnv_version "$REQUIRED_DIRENV_VERSION" 2>/dev/null; then
    _nix_direnv_fatal "base direnv version is older than the required v$REQUIRED_DIRENV_VERSION."
  fi

  if [[ -n ${NIX_BIN_PREFIX:-} ]]; then
    PATH_add "$NIX_BIN_PREFIX"
  fi

  if ! has nix; then
    _nix_direnv_fatal "command not found: nix"
  fi

  nixversion=$(nix --version)
  [[ "$nixversion" =~ ([0-9]+)[^0-9]*([0-9]+)[^0-9]*([0-9]+)? ]]
  if [[ ${BASH_REMATCH[1]} -lt 2 || ${BASH_REMATCH[1]} -eq 2 && ${BASH_REMATCH[2]} -lt 4 ]]; then
    _nix_direnv_fatal "nix version ${BASH_REMATCH[0]} is older than the required 2.4."
  fi

  # if manually reloading create a script to do the reload in $(direnv_layout_dir)/bin
  local bin
  bin="$(direnv_layout_dir)/bin"
  if [[ $_nix_direnv_manual_reload -eq 1 ]]; then
    PATH_add "$bin"
    local script="${bin}/nix-direnv-reload"
    if [[ ! -f "$script" ]]; then
      mkdir -p "$bin"
      cat > "$script" <<"EOF"
#!/usr/bin/env bash
set -eu
touch $(dirname "$(dirname "${BASH_SOURCE[0]}")")/.manual_reload
direnv reload
EOF
      chmod +x "$script"
    fi
  elif [[ -d "$bin" ]]
  then
    # otherwise clean up unwanted bin dir
    rm -rf "$bin"
  fi

}

# Usage: nix_direnv_version <version_at_least>
#
# Checks that the nix-direnv version is at least as old as <version_at_least>.
nix_direnv_version() {
  declare major='2' minor='5' patch='1' # UPDATE(nix-direnv version)

  [[ $1 =~ ^([^+-.]*)(\.?)([^+-.]*)(\.?)([^+-]*)(-?)([^+]*)(\+?)(.*)$ ]]
  declare -a ver; ver=("${BASH_REMATCH[@]:1}")

  req_major=${ver[0]}
  req_minor=${ver[2]:=0}
  req_patch=${ver[4]:=0}

  if [[ ( ${ver[0]} != +([0-9]) ) \
    || ( ${ver[1]} == '.' && ${ver[2]} != +([0-9]) ) \
    || ( ${ver[3]} == '.' && ${ver[4]} != +([0-9]) ) \
    || ( ${ver[5]} == '-' && ${ver[6]} != +([0-9A-Za-z-])*(.+([0-9A-Za-z-])) ) \
    || ( ${ver[7]} == '+' && ${ver[8]} != +([0-9A-Za-z-])*(.+([0-9A-Za-z-])) ) \
    || ( ( -n ${ver[5]} || -n ${ver[7]} ) && ( -z ${ver[2]} || -z ${ver[4]} ) ) \
  ]]; then
    _nix_direnv_fatal "error v$1 is not a valid semver version"
  fi

  if [[ ($req_major -gt $major) \
     || ($req_major -eq $major && $req_minor -gt $minor) \
     || ($req_major -eq $major && $req_minor -eq $minor && $req_patch -gt $patch)
  ]]; then
    _nix_direnv_fatal "error current version v$major.$minor.$patch is older than the desired version v$1"
  fi
}

nix_direnv_watch_file() {
  # shellcheck disable=2016
  # deprecate this in the next version.
  # log_error '`nix_direnv_watch_file` is deprecated - use `watch_file`'
  watch_file "$@"
}

_nix_direnv_manual_reload=0
nix_direnv_manual_reload() {
  _nix_direnv_manual_reload=1
}

# Usage: nix_direnv_keep_days <number of days>
#
# Keep superseded environments that have been accessed within this number of days,
# default is $_nix_direnv_keep_days
_nix_direnv_keep_days=7
nix_direnv_keep_days() {
  _nix_direnv_keep_days=$1
}

_nix_add_gcroot() {
  local storepath=$1
  local symlink=$2
  _nix build --out-link "$symlink" "$storepath"
}

_nix_export_or_unset() {
  local key=$1 value=$2
  if [[ "$value" == __UNSET__ ]]; then
    unset "$key"
  else
    export "$key=$value"
  fi
}

_nix_direnv_use() {
  local profile_name=$1
  shift

  # default watches
  watch_file "$HOME/.direnvrc" "$HOME/.config/direnv/direnvrc" "${BASH_SOURCE[0]}"

  local watches hash
  local regex='"[Pp]ath": "(.+)"$'
  while IFS= read -r line; do
    if [[ "$line" =~ $regex ]]; then
      local path="${BASH_REMATCH[1]}"
      if [[
        ! -f "$path"
        || "$path" == "${XDG_DATA_HOME:-${HOME:-/var/empty}/.local/share}/direnv/allow/"*
      ]]; then
        continue
      fi
      # expand new lines and other json escapes
      # shellcheck disable=2059
      path=$(printf "$path")
      watches+=("$path")
    fi
  done < <(direnv show_dump "${DIRENV_WATCHES}")
  # hash watched files + profile_name, profile_name needed for use_nix which adds a
  # version string to it
  hash=$(echo "$(_nix hash file "${watches[@]}")" "$profile_name" \
    | _nix hash file --base32 /dev/stdin)

  local layout_dir env current profile profile_rc manual_reload
  layout_dir=$(direnv_layout_dir)
  env="${layout_dir}/${hash}"
  current="${layout_dir}/current"
  profile="${env}/profile"
  profile_rc="${profile}.rc"
  manual_reload="${layout_dir}/.manual_reload"

  if [[ ! -d "$env" ]]; then
    # shellcheck disable=2012
    if [[
      $_nix_direnv_manual_reload -eq 1
      && -d "$current"
      && ! -f "$manual_reload"
    ]]; then
      # for manual reload warn and use the most recent environment
      _nix_direnv_warning "cache is out of date. use \"nix-direnv-reload\" to reload"
      profile_rc="${current}/profile.rc"

    else
      # update the cache

      mkdir -p "$env"
      local tmp_profile="${profile}.$$"
      if _nix print-dev-env --profile "$tmp_profile" "$@" >"$profile_rc"; then

        _nix_add_gcroot "$tmp_profile" "$profile"
        rm -f "$tmp_profile"*

        # if flake add garbage collection root for sources
        if [[ "$profile_name" == flake ]]; then
          local flake_inputs="${env}/flake-inputs"
          mkdir "$flake_inputs"
          flake_input_paths=$(_nix flake archive \
            --json --no-write-lock-file \
            "$flake_dir")
          while [[ "$flake_input_paths" =~ /nix/store/[^\"]+ ]]; do
            local store_path="${BASH_REMATCH[0]}"
            _nix_add_gcroot "${store_path}" "${flake_inputs}/${store_path##*/}"
            flake_input_paths="${flake_input_paths/${store_path}/}"
          done
        fi

        # unconditionally remove manual reload sentinel - it won't be there if not
        # manually reloading hence "-f"
        rm -f "$manual_reload"

        local status
        [[ -d "$current" ]] && status=renewed || status=created

        # clean old gc roots
        local find_old=(find "$layout_dir" -mindepth 1 -maxdepth 1 -type d \
                        ! -name bin ! -name "$hash")
        local find_rm=(-exec rm -rf {} \;)
        if [[ $_nix_direnv_keep_days -eq 0 ]]; then
          "${find_old[@]}" "${find_rm[@]}"
        else
          "${find_old[@]}" -mtime +$_nix_direnv_keep_days "${find_rm[@]}"
        fi

        _nix_direnv_info "$status cache"

        # make a link to the current env for use by stale env for manual reload or
        # cache renewal failure
        ln --force --no-dereference --symbolic --relative "$env" "$current"

      elif [[ -d "$current" ]]; then
        _nix_direnv_warning "failed to renew cache - falling back to previous"
        profile_rc="${current}/profile.rc"
      else
        _nix_direnv_fatal "failed to create cache"
      fi
    fi
  else
    # Our cache is valid, use that
    _nix_direnv_info "using cached dev shell"
  fi

  # watch the cached env to force a rebuild if it is removed
  watch_file "$env"

  # import profile
  local old_nix_build_top=${NIX_BUILD_TOP:-__UNSET__}
  local old_tmp=${TMP:-__UNSET__}
  local old_tmpdir=${TMPDIR:-__UNSET__}
  local old_temp=${TEMP:-__UNSET__}
  local old_tempdir=${TEMPDIR:-__UNSET__}
  local old_xdg_data_dirs=${XDG_DATA_DIRS:-}

  # to support nix 2.10
  # https://github.com/NixOS/nix/issues/6809
  if set +o | grep -q nounset \
    && [[ $(nix eval --expr 'builtins.compareVersions builtins.nixVersion "2.11"') -lt 0 ]]; then
    set +u
    eval "$(< "$profile_rc")"
    set -u
  else
    eval "$(< "$profile_rc")"
  fi

  # `nix print-dev-env` will create a temporary directory and use it as TMPDIR
  # We cannot rely on this directory being available at all times,
  # as it may be garbage collected.
  # Instead - just remove it immediately.
  # Use recursive & force as it may not be empty.
  if [[ -n "${NIX_BUILD_TOP+x}" && "$NIX_BUILD_TOP" == */nix-shell.* && -d "$NIX_BUILD_TOP" ]]; then
    rm -rf "$NIX_BUILD_TOP"
  fi

  _nix_export_or_unset NIX_BUILD_TOP "$old_nix_build_top"
  _nix_export_or_unset TMP "$old_tmp"
  _nix_export_or_unset TMPDIR "$old_tmpdir"
  _nix_export_or_unset TEMP "$old_temp"
  _nix_export_or_unset TEMPDIR "$old_tempdir"
  local new_xdg_data_dirs=${XDG_DATA_DIRS:-}
  export XDG_DATA_DIRS=
  local IFS=:
  for dir in $new_xdg_data_dirs${old_xdg_data_dirs:+:}$old_xdg_data_dirs; do
    dir="${dir%/}" # remove trailing slashes
    if [[ :$XDG_DATA_DIRS: = *:$dir:* ]]; then
      continue # already present, skip
    fi
    XDG_DATA_DIRS="$XDG_DATA_DIRS${XDG_DATA_DIRS:+:}$dir"
  done

}

use_flake() {
  _nix_direnv_preflight

  flake_expr="${1:-.}"
  if [[ "$flake_expr" = -* ]]; then
    local message="the first argument must be a flake expression"
    if [[ -z "${2:-}" ]]; then
      message="$message. did you mean 'use flake . $1'?"
    fi
    _nix_direnv_fatal "$message"
  fi

  flake_dir="${flake_expr%#*}"
  flake_dir=${flake_dir#"path:"}
  if [[ ! -d "$flake_dir" ]]; then
    _nix_direnv_fatal "flake directory \"$flake_dir\" not found"
  fi

  watch_file "$flake_dir/flake.nix" "$flake_dir/flake.lock" "$flake_dir/devshell.toml"

  _nix_direnv_use flake "$@"
}

use_nix() {
  _nix_direnv_preflight

  local path version
  if path=$(_nix eval --impure --expr "<nixpkgs>" 2>/dev/null); then
    if [[ -f "${path}/.version-suffix" ]]; then
      version=$(< "${path}/.version-suffix")
    elif [[ -f "${path}/.git/HEAD" ]]; then
      local head
      read -r head < "${path}/.git/HEAD"
      local regex="ref: (.*)"
      if [[ "$head" =~  $regex ]]; then
        read -r version < "${path}/.git/${BASH_REMATCH[1]}"
      else
        version="$head"
      fi
    elif [[ -f "${path}/.version" && "${path}" == "/nix/store/"* ]]; then
      # borrow some bits from the store path
      local version_prefix
      read -r version_prefix < <(cat "${path}/.version" ; echo)
      version="${version_prefix}-${path:11:16}"
    fi
  fi

  local in_packages=0
  local attribute=
  local packages=""
  local extra_args=(--impure)

  local nixfile=
  if [[ -e "shell.nix" ]]; then
    nixfile="./shell.nix"
  elif [[ -e "default.nix" ]]; then
    nixfile="./default.nix"
  fi

  while [[ "$#" -gt 0 ]]; do
    i="$1"
    shift

    case $i in
      -p|--packages)
        in_packages=1
        ;;
      --command|--run|--exclude)
        # These commands are unsupported
        # ignore them
        shift
        ;;
      --pure|-i|--keep)
        # These commands are unsupported (but take no argument)
        # ignore them
        ;;
      --include|-I)
        extra_args+=("$i" "$1")
        shift
        ;;
      --attr|-A)
        attribute="$1"
        shift
        ;;
      --option|-o|--arg|--argstr)
        extra_args+=("$i" "$1" "$2")
        shift
        shift
        ;;
      -*)
        # Other arguments are assumed to be of a single arg form
        # (--foo=bar or -j4)
        extra_args+=("$i")
        ;;
      *)
        if [[ $in_packages -eq 1 ]]; then
          packages+=" $i"
        else
          nixfile=$i
        fi
        ;;
    esac
  done

  if [[ -n "$packages" ]]; then
    extra_args+=("--expr" "with import <nixpkgs> {}; mkShell { buildInputs = [ $packages ]; }")
  else
    # figure out what attribute we should build
    if [[ -z "$attribute" ]]; then
      extra_args+=("--file" "$nixfile")
    else
      extra_args+=("--expr" "(import ${nixfile} {}).${attribute}")
    fi
  fi

  watch_file "shell.nix" "default.nix"

  _nix_direnv_use "nix-${version:-unknown}" "${extra_args[@]}"

}
